
리스폰스의 스테이터스 200은 바디가 있다는것을 나타낸다
-> 응답은 정상이지만 바디가 없을경우에는 204로 반환해야함

URI too long -> 일단 1000자 제한 걸어놓겠음.


조건부 요청: 클라이언트는 이전에 받은 리소스의 Last-Modified 값을 서버에 보내어 "If-Modified-Since" 헤더로 요청할 수 있습니다. 서버는 리소스가 해당 시간 이후에 수정되었는지 확인하고, 그렇다면 304 Not Modified 응답을 반환하여 실제 리소스를 전송하는 대신 클라이언트의 캐시를 유지합니다.


400 Bad Request: Content-Type 헤더가 누락되었거나 잘못된 경우
415 Unsupported Media Type: 서버가 요청된 데이터 형식을 지원하지 않는 경우

테스터기에서 리퀘스트를 청크드로 보내는거때문에 일단 청크드 구현 필수인듯
그리고 포스트인데 바디가 0인것도 보내는거같은데 스테이터스코드 다시 확인해봐야함

1. 웹서버 골격 만들기
2. request 파싱
3. get 요청만 만들어보기





// 포트가 중복이 되면 어떻게 하는가??
// 파이프만 이벤트에 등록하는게 아니라 pid도 등록해야함 왜냐면 평가지에서 리드 이후에 에러노를 체크하면 안된다고 되어있기 때문에.

파이프도 등록하고
pid도 등록하고
파이프 등록하면 바디에 붙이기만 하고
child 이벤트 발생하면 그때 완성해서 리스폰스 센더에 보내는걸로.

nginx 파싱
ex)
```
http { 
    server {
        listen 4242;
        listen 4000;
        server_name a;
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location asdf {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location .php {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location .py {
            cgi sjdfilasdjfli;
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
    server {
        listen 8080;
        server_name b;
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
    }
    }
}
```
 * location / { } 이부분이 location block이라고 한다
    * location block은 여러개가 있을 수 있다
    * location block은 가장 긴것이 우선순위가 높다
    * location block은 = ~ ^~ ~* ~*가 있다
    * = : 정확히 일치
    * ~ : 대소문자 구분
    * ~* : 대소문자 구분하지 않음
    * ^~ : 정확히 일치하면 뒤에꺼 무시
    * / : 가장 긴것이 우선순위가 높다
    

request 파싱
 * request line - method sp request-target sp http-version crlf \r\n
 * method : get post put delete 이외에 에러
 * request-target : 맨처음 / 없으면 에러
 * http-version : HTTP/1.0 HTTP/1.1 이외에 에러
 * 제일 뒤에 /r없으면 에러


requestline\r\n
headerline ...\r\n
...\r\n
...\r\n
\r\n
body\r\n



header 파싱
 * header-field : field-name : OWS field-value OWS
 * field-name에 ()<>@,;:\\\"/[]?={} \t\r\n\"\\^`|~ 있으면 에러
 * field-value 제일 뒤에 '\r' 없으면 에러
 * field-name 중복 에러 -> 이건 확인 해봐야함 캐시같은 경우 중복이 있을 수 있음 -> 중복이면 중복안되는 거 제외하고 이어야돼 
 ex)
 sec-ch-ua: "Chromium";v="116"
 sec-ch-ua: "Not)A;Brand";v="24"



 * content-length 있으면 body파싱 content-length의 값이 마이너스거나 숫자가 아니면 에러
 ** 헤더가 버퍼의 크기보다 커버리면 문제가 발생!! - 해결! \r\n\r\n 찾을때까지 읽기!
 * host는 무조건 있어야한다

body파싱 buff 1024
 * 나머지 바디부분 파싱하고 body size와 content size 비교해서 body size가 부족하면 더읽고 붙이기



get 요청
 * HttpResponse 클래스를 만들고 HttpRequest클래스를 받는다
 * httpRequest에서 받아오는것은 유효성 검사가 끝났으니 따로 처리해주지 않아도 된다
 ** path에 대한 에러처리 또 해야된다 ex) /../  <- 대부분의 클라이언트단에서 막혀있지만 보안상 막아주자, 또 뭐가 있을지 생각
 * 파일 없을 때 404
 * 권한 403



nginx config 참고
https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/


http 참고
https://hochan049.gitbook.io/cs-interview/web/rfc-7320
https://developer.mozilla.org/ko/docs/Web/HTTP
https://roka88.dev/105


3/15
1. post 요청 만들어보기
2. delete 요청 만들어보기
3. put 요청 만들어보기
4. head 요청 만들어보기
5. options 요청 만들어보기
6. cgi 만들어보기
7. wordpress 실행해보기





class configs
{
    public:
        config();
        ~config();
        config &operator=(const config &rhs);
        config(const config &rhs);
        void setConfig(std::string configPath);
        std::map<int, config>& getConfig() const;
};

class config
{
    public:
        config();
        config(std::string root, std::string port, std::string serverName, std::string location, std::vector<std::string> method);
        ~config();
        config &operator=(const config &rhs);
        config(const config &rhs);
        std::string& getRoot() const;
        std::string& getPort() const;
        std::string& getServerName() const;
        std::string& getLocation() const;
        std::vector<std::string>& getMethod() const;
};

class server
{
    pubilc:
        server();
        ~server();
        server &operator=(const server &rhs);
        server(const server &rhs);
        void setServer(configs &config);
        void runServer();
};

class request
{
    public:
        request();
        request(int clientFd);
        ~request();
        request &operator=(const request &rhs);
        request(const request &rhs);
        void parseRequest();
};



















content length 규칙

1. 읽었는데 body가 content length보다 작을때 -> 1024 다읽었을때 작으면 이거는 더읽을 여지가 있어 or 읽은게 1024보다 작으면 더 읽을게 없잖어 그럼 에러처리
2. 읽었는데 body가 content length보다 클때 -> 걍 content length만큼만 처리하고 무시 버려 버려