
리스폰스의 스테이터스 200은 바디가 있다는것을 나타낸다
-> 응답은 정상이지만 바디가 없을경우에는 204로 반환해야함

URI too long -> 일단 1000자 제한 걸어놓겠음.


조건부 요청: 클라이언트는 이전에 받은 리소스의 Last-Modified 값을 서버에 보내어 "If-Modified-Since" 헤더로 요청할 수 있습니다. 서버는 리소스가 해당 시간 이후에 수정되었는지 확인하고, 그렇다면 304 Not Modified 응답을 반환하여 실제 리소스를 전송하는 대신 클라이언트의 캐시를 유지합니다.


400 Bad Request: Content-Type 헤더가 누락되었거나 잘못된 경우
415 Unsupported Media Type: 서버가 요청된 데이터 형식을 지원하지 않는 경우


실행부에서 cgi를 실행한 뒤, 쓰기이벤트에 쓰기파이프등록, 읽기이벤트에 읽기파이프 등록,
자식프로세스 종료이벤트에 cgi프로세스 등록 하고 난 뒤, 정보들을 모두 담고있는 execinfo 클래스를 
동적생성으로 만들고 주소를 이용해 해시를 만들어 맵에다 등록한다.
그리고 실행전용 map에다가 쓰기파이프와 해시, 읽기파이프와 해시, pid와 해시를 등록해준다.
-> 그래야 각각 이벤트때 해당하는 정보를 찾아서 처리할 수 있기 때문이다.
그럼 이제 문제점.
만약 이미 하나의 cgi처리를 하는 중에, 같은 클라이언트로부터 cgi요청이 하나 더들어와서 처리하다가
중간에 먼저 처리중이였던 놈이 비정상종료로 인해 클라이언트를 닫아주게 될 경우
이때 클라이언트 파이프를 먼저 닫아줄 것임. 그럼 두번째 요청이 처리되고 나서 write이벤트 등록하는일이
생기면 안되는데?
-> 이건 getsockname의 반환값을 검사해서 이미 닫힌놈인지 확인해줘야 할거같다.

리리스폰스 센더가 왜 fd안받고 그냥 완성된거 다 쏘는지 확인?

1. 웹서버 골격 만들기
2. request 파싱
3. get 요청만 만들어보기


오늘
1. accept
3. redirection

2. chunked

index.php 연 탭에서 두개가 pending인 상태
-> 그중 한 파일 url을 탭 새로열어서 해봄
-> 걔도 계속 로딩인상태
-> 이상태에서 index.php탭을 닫았더니 다른 탭이 로딩이 끝남
-> ???




// 포트가 중복이 되면 어떻게 하는가??
// 파이프만 이벤트에 등록하는게 아니라 pid도 등록해야함 왜냐면 평가지에서 리드 이후에 에러노를 체크하면 안된다고 되어있기 때문에.

파이프도 등록하고
pid도 등록하고
파이프 등록하면 바디에 붙이기만 하고
child 이벤트 발생하면 그때 완성해서 리스폰스 센더에 보내는걸로.

nginx 파싱
ex)
```
http { 
    server {
        listen 4242;
        listen 4000;
        server_name a;
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location asdf {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location .php {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location .py {
            cgi sjdfilasdjfli;
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
    server {
        listen 8080;
        server_name b;
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
    }
    }
}
```
 * location / { } 이부분이 location block이라고 한다
    * location block은 여러개가 있을 수 있다
    * location block은 가장 긴것이 우선순위가 높다
    * location block은 = ~ ^~ ~* ~*가 있다
    * = : 정확히 일치
    * ~ : 대소문자 구분
    * ~* : 대소문자 구분하지 않음
    * ^~ : 정확히 일치하면 뒤에꺼 무시
    * / : 가장 긴것이 우선순위가 높다
    

request 파싱
 * request line - method sp request-target sp http-version crlf \r\n
 * method : get post put delete 이외에 에러
 * request-target : 맨처음 / 없으면 에러
 * http-version : HTTP/1.0 HTTP/1.1 이외에 에러
 * 제일 뒤에 /r없으면 에러


requestline\r\n
headerline ...\r\n
...\r\n
...\r\n
\r\n
body\r\n



header 파싱
 * header-field : field-name : OWS field-value OWS
 * field-name에 ()<>@,;:\\\"/[]?={} \t\r\n\"\\^`|~ 있으면 에러
 * field-value 제일 뒤에 '\r' 없으면 에러
 * field-name 중복 에러 -> 이건 확인 해봐야함 캐시같은 경우 중복이 있을 수 있음 -> 중복이면 중복안되는 거 제외하고 이어야돼 
 ex)
 sec-ch-ua: "Chromium";v="116"
 sec-ch-ua: "Not)A;Brand";v="24"



 * content-length 있으면 body파싱 content-length의 값이 마이너스거나 숫자가 아니면 에러
 ** 헤더가 버퍼의 크기보다 커버리면 문제가 발생!! - 해결! \r\n\r\n 찾을때까지 읽기!
 * host는 무조건 있어야한다

body파싱 buff 1024
 * 나머지 바디부분 파싱하고 body size와 content size 비교해서 body size가 부족하면 더읽고 붙이기



get 요청
 * HttpResponse 클래스를 만들고 HttpRequest클래스를 받는다
 * httpRequest에서 받아오는것은 유효성 검사가 끝났으니 따로 처리해주지 않아도 된다
 ** path에 대한 에러처리 또 해야된다 ex) /../  <- 대부분의 클라이언트단에서 막혀있지만 보안상 막아주자, 또 뭐가 있을지 생각
 * 파일 없을 때 404
 * 권한 403



nginx config 참고
https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/


http 참고
https://hochan049.gitbook.io/cs-interview/web/rfc-7320
https://developer.mozilla.org/ko/docs/Web/HTTP
https://roka88.dev/105


3/15
1. post 요청 만들어보기
2. delete 요청 만들어보기
3. put 요청 만들어보기
4. head 요청 만들어보기
5. options 요청 만들어보기
6. cgi 만들어보기
7. wordpress 실행해보기





class configs
{
    public:
        config();
        ~config();
        config &operator=(const config &rhs);
        config(const config &rhs);
        void setConfig(std::string configPath);
        std::map<int, config>& getConfig() const;
};

class config
{
    public:
        config();
        config(std::string root, std::string port, std::string serverName, std::string location, std::vector<std::string> method);
        ~config();
        config &operator=(const config &rhs);
        config(const config &rhs);
        std::string& getRoot() const;
        std::string& getPort() const;
        std::string& getServerName() const;
        std::string& getLocation() const;
        std::vector<std::string>& getMethod() const;
};

class server
{
    pubilc:
        server();
        ~server();
        server &operator=(const server &rhs);
        server(const server &rhs);
        void setServer(configs &config);
        void runServer();
};

class request
{
    public:
        request();
        request(int clientFd);
        ~request();
        request &operator=(const request &rhs);
        request(const request &rhs);
        void parseRequest();
};



















content length 규칙

1. 읽었는데 body가 content length보다 작을때 -> 1024 다읽었을때 작으면 이거는 더읽을 여지가 있어 or 읽은게 1024보다 작으면 더 읽을게 없잖어 그럼 에러처리
2. 읽었는데 body가 content length보다 클때 -> 걍 content length만큼만 처리하고 무시 버려 버려



GET / HTTP/1.1
HOST: 127.0.0.1:1111

POST / HTTP/1.1
HOST: 127.0.0.1:1111


오시발 호스트 포트가 다를경우도 고려해야하는듯?
현현재 구조상, 1111포트로 호스트 4444로 보내게되면 처리 이후에 4444에 해당하는게 없어서 못보냄!

